#!/usr/bin/env python
"""
Detect import statements using the AST parser.

This script outputs a comma-separated list of tuples:

  ((from_root, from_filename), (to_root, to_filename))
  
The roots are the root directories where the modules lie.  You can use
snakefood-graph or some other tool to filter, cluster and generate a meaningful
graph from this list of dependencies.

As a special case, if the 'to' tuple is (None, None), this means to at least
include the 'from' tuple as a node.  This may happen if the file has no
dependencies on anything.

See http://furius.ca/snakefood for details.
"""

import sys, os, logging, traceback
import imp, compiler
from os.path import *
from collections import defaultdict
from operator import itemgetter


class ImportVisitor(object):
    "AST visitor for grabbing the import statements."

    def __init__(self):
        self.modules = set()

    def visitImport(self, node):
        self.modules.update(x[0] for x in node.names)

    def visitFrom(self, node):
        modname = node.modname
        for name, as_ in node.names:
            if name != '*':
                name = '.'.join((modname, name))
            else:
                name = modname
            self.modules.add(name)

def process_file(fn):
    "Returns a list of the files it depends on."
    try:
        mod = compiler.parseFile(fn)
    except Exception, e:
        logging.error("Error processing file '%s':\n\n%s" %
                      (fn, traceback.format_exc(sys.stderr)))
        return []
        
    vis = ImportVisitor()
    compiler.walk(mod, vis)

    files = []
    for mod in vis.modules:
        modfile = find_dotted_module(mod, fn)
        if modfile is None:
            continue
        files.append(modfile)
    return files

def find_dotted_module(modname, fn):
    """A version of find_module that supports dotted module names (packages)."""

    names = modname.split('.')
    path = sys.path + [dirname(fn)]
    file_ = None
    for name in names:
        try:
            (file_, pathname, description) = imp.find_module(name, path)
            if not isdir(pathname):
                pathname = dirname(pathname)
            path = [pathname]
        except ImportError, e:
            logging.debug("Not a module: '%s'" % modname)
            break
    out = file_ and realpath(file_.name)
    return out

def iter_pyfiles(dirsorfn, ignores=('.svn', 'CVS')):
    """Yield all the files ending with .py recursively.  'dirsorfn' is a list of
    filenames or directories."""
    for dn in dirsorfn:
        dn = realpath(dn)

        if not isdir(dn):
            if dn.endswith('.py'):
                yield dn

        else:
            for root, dirs, files in os.walk(dn):
                for r in ignores:
                    try:
                        dirs.remove(r)
                    except ValueError:
                        pass

                pyfiles = [fn for fn in files if fn.endswith('.py')]
                if not pyfiles:
                    continue
                for fn in pyfiles:
                    yield join(root, fn)

def find_packroot(fn):
    "Returns the package root for the given Python file."
    # Find the root of the packages.
    packroot = realpath(fn)
    if not isdir(packroot):
        packroot = dirname(packroot)
    while 1:
        if not exists(join(packroot, '__init__.py')):
            break
        packroot = dirname(packroot)
    return packroot

def relfile(fn):
    "Return pairs of (package root, relative filename)."
    root = find_packroot(realpath(fn))
    return root, fn[len(root)+1:]

# (Refactor candidate.)
def output_depends(depdict):
    """Given a dictionary of (from -> list of targets), generate an appropriate
    output file."""

    # Output the dependencies.
    write = sys.stdout.write
    for (from_root, from_), tolist in sorted(depdict.iteritems(),
                                             key=itemgetter(0)):
        for to_root, to_ in sorted(tolist):
            write(repr( ((from_root, from_), (to_root, to_)) ))
            write('\n')

def main():
    import optparse
    parser = optparse.OptionParser(__doc__.strip())

    parser.add_option('--debug', action='store_true', help="Turn on debugging")

    opts, args = parser.parse_args()
    logging.basicConfig(level=logging.DEBUG if opts.debug else logging.INFO)
    if not args:
        logging.warning("Searching for files from root directory.")
        args = ['.']

    # Find all the dependencies.
    allfiles = defaultdict(set)
    for fn in iter_pyfiles(args):
        logging.info("Processing %s" % fn)
        files = process_file(fn)

        # Make sure all the files at least appear.
        allfiles[relfile(fn)].add((None, None)) 

        # Add the dependencies.
        for xfn in files:
            allfiles[relfile(fn)].add(relfile(xfn))

    # Output the list of roots found.
    logging.info("Found roots:")
    for root in frozenset(x[0] for x in allfiles.iterkeys()):
        logging.info('  %s' % root)

    output_depends(allfiles)
    


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        raise SystemExit("Interrupted.")


