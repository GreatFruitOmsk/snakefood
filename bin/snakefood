#!/usr/bin/env python
"""
Detecting import statements using the AST parser.

This script outputs a comma-separated list of tuples:

  (from_root, from_filename, to_root, to_filename)
  
The roots are the root directories where the modules lie.  You can use
snakefood-graph or some other tool to filter, cluster and generate a meaningful
graph from this list of dependencies.

See http://furius.ca/snakefood for details.
"""

import sys, os, logging
import imp, compiler
from os.path import *
from collections import defaultdict
from operator import itemgetter


class ImportVisitor(object):
    "AST visitor for grabbing the import statements."

    def __init__(self):
        self.modules = set()

    def visitImport(self, node):
        self.modules.update(x[0] for x in node.names)

    def visitFrom(self, node):
        modname = node.modname
        for name, as_ in node.names:
            if name != '*':
                name = '.'.join((modname, name))
            else:
                name = modname
            self.modules.add(name)

def process_file(fn):
    "Returns a list of the files it depends on."
    mod = compiler.parseFile(fn)

    vis = ImportVisitor()
    compiler.walk(mod, vis)

    files = []
    for mod in vis.modules:
        modfile = find_dotted_module(mod, fn)
        if modfile is None:
            continue
        files.append(modfile)
    return files

def find_dotted_module(modname, fn):
    """A version of find_module that supports dotted module names (packages)."""

    names = modname.split('.')
    path = sys.path + [dirname(fn)]
    file_ = None
    for name in names:
        try:
            (file_, pathname, description) = imp.find_module(name, path)
            if not isdir(pathname):
                pathname = dirname(pathname)
            path = [pathname]
        except ImportError, e:
            logging.debug("Not a module: '%s'" % modname)
            break
    out = file_ and realpath(file_.name)
    return out

def iter_pyfiles(dirsorfn, ignores=('.svn', 'CVS')):
    """Yield all the files ending with .py recursively.  'dirsorfn' is a list of
    filenames or directories."""
    for dn in dirsorfn:
        dn = realpath(dn)

        if not isdir(dn):
            if dn.endswith('.py'):
                yield dn

        else:
            for root, dirs, files in os.walk(dn):
                for r in ignores:
                    try:
                        dirs.remove(r)
                    except ValueError:
                        pass

                pyfiles = [fn for fn in files if fn.endswith('.py')]
                if not pyfiles:
                    continue
                for fn in pyfiles:
                    yield join(root, fn)

def find_packroot(fn):
    "Returns the package root for the given Python file."
    # Find the root of the packages.
    packroot = realpath(fn)
    if not isdir(packroot):
        packroot = dirname(packroot)
    while 1:
        if not exists(join(packroot, '__init__.py')):
            break
        packroot = dirname(packroot)
    return packroot

def relfile(fn):
    "Return pairs of (package root, relative filename)."
    root = find_packroot(realpath(fn))
    return root, fn[len(root)+1:]

def filter_p(opts, root, fn):
    "Return true if the file should be ignored."
    if not opts.filter:
        return False
    elif root in opts.filter_paths:
        return False
    else:
        return True

def main():
    import optparse
    parser = optparse.OptionParser(__doc__.strip())

    parser.add_option('-f', '--filter', action='append', default=[],
                      help="Filter the results by include only the given path prefixes.")

    parser.add_option('-c', '--cluster', '--group', action='append', default=[],
                      dest='cluster_dirs',
                      help="Add a cluster to reduce the filenames by.  "
                      "The clusters should be pathnames.")

    parser.add_option('--debug', action='store_true', help="Turn on debugging")

    opts, args = parser.parse_args()
    if opts.filter:
        opts.filter_paths = map(realpath, opts.filter)
    if opts.cluster_dirs:
        opts.cluster_dirs = map(relfile, opts.cluster_dirs)

    logging.basicConfig(level=logging.DEBUG if opts.debug else logging.INFO)

    # Find all the dependencies.
    allfiles = defaultdict(set)
    for fn in iter_pyfiles(args):
        logging.info("Processing %s" % fn)
        files = process_file(fn)
        for xfn in files:
            allfiles[relfile(fn)].add(relfile(xfn))

    # Output the list of roots found.
    logging.info("Found roots:")
    for root in frozenset(x[0] for x in allfiles.iterkeys()):
        logging.info('  %s' % root)

    # Output the dependencies.
    write = sys.stdout.write
    for (from_root, from_), tolist in sorted(allfiles.iteritems(),
                                             key=itemgetter(0)):
        for to_root, to_ in sorted(tolist):
            write(','.join((from_root, from_, to_root, to_)))
            write('\n')


if __name__ == '__main__':
    main()



