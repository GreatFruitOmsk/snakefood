#!/usr/bin/env python
"""
Detect import statements using the AST parser.

This script outputs a comma-separated list of tuples:

  ((from_root, from_filename), (to_root, to_filename))

The roots are the root directories where the modules lie.  You can use
snakefood-graph or some other tool to filter, cluster and generate a meaningful
graph from this list of dependencies.

As a special case, if the 'to' tuple is (None, None), this means to at least
include the 'from' tuple as a node.  This may happen if the file has no
dependencies on anything.

See http://furius.ca/snakefood for details.
"""

import sys, os, logging, traceback
import imp, compiler
from os.path import *
from collections import defaultdict
from operator import itemgetter


class ImportVisitor(object):
    "AST visitor for grabbing the import statements."

    def __init__(self):
        self.modules = set()

    def visitImport(self, node):
        self.modules.update((x[0], None) for x in node.names)

    def visitFrom(self, node):
        modname = node.modname
        for name, as_ in node.names:
            if name != '*':
                mod = (modname, name)
            else:
                mod = (modname, None)
            self.modules.add(mod)

def process_file(fn):
    "Returns a list of the files it depends on."
    try:
        mod = compiler.parseFile(fn)
    except Exception, e:
        logging.error("Error processing file '%s':\n\n%s" %
                      (fn, traceback.format_exc(sys.stderr)))
        return []

    vis = ImportVisitor()
    compiler.walk(mod, vis)

    files = []
    assert not isdir(fn)
    dn = dirname(fn)
    for mod, sub in vis.modules:
        modfile = find_dotted_module(mod, sub, dn)
        if modfile is None:
            continue
        files.append(modfile)
    return files





try:
    from imp import ImpImporter
except ImportError:
    from pkgutil import ImpImporter
def_imper = ImpImporter()

def find_dotted_module(modname, sub, parentdir):
    """
    A version of find_module that supports dotted module names (packages).
    This function returns the path of the found module.

    If 'sub' is not None, it first attempts to import 'modname.sub', and if it
    fails, it must therefore not be a module, so we look up 'modname'.

    'parentdir' is the directory of the file that attempts to do the import.  We
    attempt to do a local import there first.
    """
    names = modname.split('.')
    if sub is not None:
        names.append(sub)
        
    path = [parentdir]
    out = None

    curnames = []
    for i, n in enumerate(names):
        curnames.append(n)
        name = '.'.join(curnames)
        
        # Try local import first.
        mod = ImpImporter(parentdir).find_module(name)
        if mod:
            out = mod.get_filename()
            if out is None:
                trace(out)
                break
            parentdir = dirname(out)
            continue

        # Try global import otherwise
        mod = def_imper.find_module(name)
        if mod:
            out = mod.get_filename()
            if out is None:
                trace(out)
                break
            parentdir = dirname(out)
            continue

    if out is None:
        # Note: builtin modules will not show up.  Maybe we should do something
        # special for them.
        logging.warning("Not a module: '%s'" % modname)
    else:
        return out



def find_dotted_module__OLD(modname, sub, parentdir):

    names = modname.split('.')
    path = [parentdir]
    out = None

    for name in names:

        # Try local import.
        try:
            (file_, pathname, description) = imp.find_module(name, path)
        except ImportError, e:
            # Try import from builtins, inroots, sys.path.
            try:
                (file_, pathname, description) = imp.find_module(name, None)
            except ImportError, e:
                logging.debug("Not a module: '%s'" % modname)
                break # Still import the parent of this.

        out = pathname
        if not isdir(pathname):
            pathname = dirname(pathname)
        path = [pathname]

    if out:
        out = realpath(out)
    return out


def iter_pyfiles(dirsorfn, ignores=('.svn', 'CVS')):
    """Yield all the files ending with .py recursively.  'dirsorfn' is a list of
    filenames or directories."""
    for dn in dirsorfn:
        dn = realpath(dn)

        if not isdir(dn):
            if dn.endswith('.py'):
                yield dn

        else:
            for root, dirs, files in os.walk(dn):
                for r in ignores:
                    try:
                        dirs.remove(r)
                    except ValueError:
                        pass

                pyfiles = [fn for fn in files if fn.endswith('.py')]
                if not pyfiles:
                    continue
                for fn in pyfiles:
                    yield join(root, fn)

def find_package_root(fn):
    "Returns the package root for the given Python file."
    # Find the root of the packages.
    packroot = realpath(fn)
    if not isdir(packroot):
        packroot = dirname(packroot)
    while 1:
        if not exists(join(packroot, '__init__.py')):
            break
        packroot = dirname(packroot)
    return packroot

def relfile(fn):
    "Return pairs of (package root, relative filename)."
    root = find_package_root(realpath(fn))
    return root, fn[len(root)+1:]

# (Refactor candidate.)
def output_depends(depdict):
    """Given a dictionary of (from -> list of targets), generate an appropriate
    output file."""

    # Output the dependencies.
    write = sys.stdout.write
    for (from_root, from_), targets in sorted(depdict.iteritems(),
                                             key=itemgetter(0)):
        for to_root, to_ in sorted(targets):
            write(repr( ((from_root, from_), (to_root, to_)) ))
            write('\n')

def main():
    import optparse
    parser = optparse.OptionParser(__doc__.strip())

    parser.add_option('-i', '--internal', '--internal-only', action='store_true',
                      help="Filter out dependencies that are outside of the "
                      "roots of the input files")

    parser.add_option('--debug', action='store_true', help="Turn on debugging")

    opts, args = parser.parse_args()
    logging.basicConfig(level=logging.DEBUG if opts.debug else logging.INFO)
    if not args:
        logging.warning("Searching for files from root directory.")
        args = ['.']

    # Get the list of package roots for our input files and prepend them to the
    # module search path to insure localized imports.
    inroots = sorted(map(find_package_root, args))
    logging.info("Roots of input:")
    for root in inroots:
        logging.info('  %s' % root)

    logging.info("")
    logging.info("Using path:")
    sys.path = inroots + sys.path
    for dn in sys.path:
        logging.info("  %s" % dn)

    # Find all the dependencies.
    logging.info("")
    logging.info("Processing files")
    allfiles = defaultdict(set)
    for fn in iter_pyfiles(args):
        logging.info("  %s" % fn)
        files = process_file(fn)

        # When packages are the source of dependencies, remove the __init__
        # file.  This is important because the targets also do not include the
        # __init__ (i.e. when "from <package> import <subpackage>" is seen).
        if basename(fn) == '__init__.py':
            fn = dirname(fn)

        # Make sure all the files at least appear.
        allfiles[relfile(fn)].add((None, None))

        # Add the dependencies.
        for xfn in files:
            if basename(xfn) == '__init__.py':
                xfn = dirname(xfn)

            allfiles[relfile(fn)].add(relfile(xfn))

    # Output the list of roots found.
    logging.info("")
    logging.info("Found roots:")
    for root in sorted(frozenset(x[0] for x in allfiles.iterkeys())):
        logging.info('  %s' % root)

    if opts.internal:
        # Filter out the dependencies that lie outside of the package roots of
        # the input files.
        #
        # Note: this *could* be moved to another script.
        inroots = frozenset(inroots)
        for from_, targets in allfiles.items():
            if from_[0] not in inroots:
                del allfiles[from_]
                continue
            for to_ in set(targets):
                if to_[0] not in inroots:
                    targets.remove(to_)

    # Output the dependencies.
    output_depends(allfiles)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        raise SystemExit("Interrupted.")


