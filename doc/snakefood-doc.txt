===========================
   Snakefood User Manual
===========================
:Date: 2007-05-10
:Author: Martin Blais <blais@furius.ca>

.. contents::
..
    1  Introduction
      1.1  What is a Dependency?
    2  30-seconds Usage Instructions
    3  Installation
    4  Overview
    5  Generating Dependencies
      5.1  How Packages Are Automatically Found
      5.2  Following Dependencies
      5.3  Restricting Dependencies
      5.4  The Format of Dependencies Files
      5.5  Caching Raw Dependencies
      5.6  Warnings
        5.6.1  Nodes Without Dependencies
    6  Filtering and Clustering Dependencies
      6.1  Using Standard UNIX Tools
      6.2  Using ``snakefood-cluster``
    7  Using a Makefile
    8  Feedback and Comments


Introduction
============

This is the documentation for Snakefood, a dependency graph generator
for Python source code (written in Python).

What is a Dependency?
---------------------

In this document, dependencies are import relationships between Python
source files.  If file ``a.py`` imports some code from file ``b.py``,
we say that ``a.py`` *depends on* ``b.py``, or that ``a.py`` has a
dependency on ``b.py``.

Controlling the dependencies between the various parts of your code
(or between projects that your code uses) is a powerful way to
increase the reusability of your code: the least amount of
dependencies a body of source code has, the greater the likelihood
that this code will be usable in the future.  Dependencies cause codes
to break due to the independent evolution of modules and changes in
the interfaces.  Even within a single project, controlling
dependencies between layers is the essence of modularity.

Snakefood allows you to automatically generate a visual graph of those
dependencies.  When you produce these kinds of graphs, you will often
be surprised at how certain parts of your code inadvertently become
tied together.  Dependency graphs allow you to view the relationships
clearly and will generate questions about the high-level organization
of your code and allow to improve modularity and reusability.


30-seconds Usage Instructions
=============================

(For the impatient.)  You will need Graphviz.  Snakefood generates a
dot file (Graphviz input file).  Here is the simplest way to generate
a graph::

   snakefood /myproject | snakefood-graph | dot -Tps | pstopdf -i -o myproject.pdf

However **this will probably not do what you want**, unless your
project is pretty small.  The dependency graphs for reasonably sized
projects are generally complex, and you will want to filter out some
of the dependencies, and cluster some of them in logical groups of
files or by directory (see the text for the ``snakefood-cluster``
tool).

Read on for more details on how to use these tools.


Installation
============

- You need to install Python-2.5 or greater.

- You need to Graphviz tools to generate graphs.  Snakefood produces
  input files for Graphviz.

- To install the Snakefood tools themselves, just run the usual
  distutils command::

     cd snakefood-<version>
     python setup.py install   # as root


Overview
========

Snakefood provides three main tools:

1. ``snakefood``: Given a set of input files or root directories,
   generate a list of dependencies between the files;

2. ``snakefood-graph``: Read a list of dependencies and produce a
   Graphviz dot file.  This file can be run through the Graphviz
   ``dot`` tool to produce a viewable/printable PDF file;

3. ``snakefood-cluster`` (optional use): Read a list of dependencies,
   a list of file clusters, and output a list of simplified
   (clustered) dependencies.

Typically, you will use ``snakefood`` to generate the dependencies,
pass those on to ``snakefood-graph`` and pass its output to ``dot`` to
generate your output PDF file.

.. figure:: programs1.png

   Simple pipeline for generating a full dependency graph.


Generating Dependencies
=======================

To generate the dependencies, you use the ``snakefood`` tool, giving
it a list of filenames::

  snakefood file1.py file2.py file3.py

You can also use directories::

  snakefood /path/to/my/project

If you specify directories, ``snakefood`` will recurse through them
and automatically find all the Python source files and process them.
Each file is processed independently, giving the file to ``snakefood``
means “output the dependencies of this file”.

``snakefood`` finds the dependencies in your source files using the
AST parser.  It does not figure out which ``import`` statements run
conditionally; it simply finds all the imports in the file and outputs
dependencies for each of them.

.. note::

   Note that none of the module your specify on the command-line are
   loaded nor run.  Loading modules is almost always problem, because
   a lot of codebases run initialization code in the global namespace,
   which often requires additional setup.  Snakefood is guaranteed not
   to have this problem: it does not run your code, it just looks at
   it; the worst thing that can happen is that it misses some
   dependencies.

   A problem with dependency trackers that run code is that they are
   unreliable too, due to the dynamic nature of Python: the presence
   of imports within function calls and ``__import__`` hooks makes it
   almost impossible to always do the right thing.  This script aims
   at being right 95% of the time, and we think that given the
   trade-offs, 95% is good enough for 95% of its uses.


How Packages Are Automatically Found
------------------------------------

For each file or directory that you specify on the command-line,
``snakefood`` automatically figures out which package it lives in.  It
does this by walking up the directory hierarchy of each file until it
finds a directory without a ``__init__.py`` file.

All of the package roots found this way are automatically prepended to
the Python import path, so you do not have to configure your
PYTHONPATH before you invoke ``snakefood``.  The roots are also used
to separate the filename in two parts: the package root, and the
filename relative to that root (see the section on dependencies format
below).


Following Dependencies
----------------------

By default, ``snakefood`` does not *follow* dependencies, that is, if
you ask it to process ``a.py`` and it finds that it has a dependency
on ``b.py``, the file ``b.py`` does not get processed for its
dependencies.

Use the ``--follow`` option to tell ``snakefood`` to follow its
dependencies.  Files for each target dependency that were found are
automatically examined for dependencies, and the process continues
until all leaves are found (we check for cycles too).


Restricting Dependencies
------------------------

Normally you will want to find out the relationships only between
files in the packages that you provide on the command-line.  For
example, you will probably not be interested to find out about
dependencies to the modules in the standard library that comes with
Python.

You can filter out the dependencies by yourself using the usual UNIX
tools, like grep or sed.  But since this is a typical case, there is a
convenient --internal-only option to snakefood that automatically
limits dependencies to the package roots corresponding to the files
that you specify on the command-line.

.. note:: 

   Subdirectories that live under a package root but which do not have
   an appropriate ``__init__.py`` file are considered external to the
   containing package root (because they are distinct).  Large
   codebases often have such directories containing test scripts,
   installation code and what not, which cannot be imported directly.
   Add those directories to the command-line if you want to include
   them while using the ``--internal`` option.


The Format of Dependencies Files
--------------------------------

The format of dependencies is really simple::

  ((<source_package_root>, <source_file.py>), (<dest_package_root>, <dest_file.py>))

where the ``package_root`` files are the directory names at the root
where the module files are found, and the ``file.py`` names are the
Python filenames relative to the corresponding root.  

Each line is a valid Python tuple expression, so you can easily write
a Python script to process them using a line like::

  for dep in map(eval, sys.stdin):
      ...

and output them like::

      dep = (froot, fn), (troot, tn)
      print repr(dep)


Caching Raw Dependencies
------------------------

The process of building a nicely filtered dependency graph is
iterative, you will typically massage the dependencies to highlight
the relationships that you care about.  Since calculating the
dependencies can be a slow process (and filtering and graph generation
is not), we recommend to save the output of ``snakefood`` to a file
and work from that.


Warnings
--------

You may see a lot of warnings when you run ``snakefood``.  This is
normal.  There are a few reasons for this:

- The code you are analyzing requires some external packages that are
  not installed or not in your PYTHONPATH;

- The ``from-import`` Python syntax is ambiguous; for example, in the
  following code, it is not clear whether ``table`` is a module or an
  object defined in the ``database`` module::

     from database import table

  Therefore, ``snakefood`` does not normally print out warnings for
  these.  If you want to see a list of those failed imports, run it
  with the ``--verbose`` option.

In eitehr case ``snakefood`` keeps running and produces all the other
dependencies that it finds.


Nodes Without Dependencies
~~~~~~~~~~~~~~~~~~~~~~~~~~

To insure that all the file nodes show up in the graph, for each
processed file we output a line like this::

  ((<source_package_root>, <source_file.py>), (None, None))

The graphing tool interprets that to mean it has to at least create a
node for ``<source_file>.py``, even if it has no dependency.  Scripts
you write to filter the dependencies need to be able to interpret
those lines appropriately.


Filtering and Clustering Dependencies
=====================================

Using Standard UNIX Tools
-------------------------

Since dependencies are simple line-based Python expressions, you can
use ``grep`` or ``sed`` to filter out or modify unwanted lines::

  cat raw.deps | grep -v /usr/lib/python | snakefood-graph > out.dot

There is no formula for filtering or reformatting the dependencies; it
depends on your codebase and what you want the graph to show.


Using ``snakefood-cluster``
---------------------------

A useful operation is to transform the relative filenames into logical
groups and to remove redundant lines.  We call this “clustering”.  A
common example is to lump together all the filenames that start with a
particular directory prefix.

You could do this with ``sed`` but you also need to remove redundant
lines to do it properly, i.e. after simplification of the relative
filenames, multiple lines will be equivalent.  ``snakefood-cluster``
does that automatically.  You create a file of cluster names::

   pack1
   pack2
   
and a dependency file will be transformed from this::

  (('/myproject', 'pack1/person.py'), ('/myproject', 'pack1/employee.py'))
  (('/myproject', 'pack1/person.py'), ('/myproject', 'pack1/manager.py'))
  (('/myproject', 'pack1/person.py'), ('/myproject', 'pack2/boss.py'))

to this::

  (('/myproject', 'pack1'), ('/myproject', 'pack1'))
  (('/myproject', 'pack1'), ('/myproject', 'pack2'))

Here is how to use the ``snakefood-cluster`` tool::

   snakefood /myproject | snakefood-cluster -f clusters | snakefood-graph > myproject.dot

.. figure:: programs2.png

   Pipeline for dependency graph with clustering.

You can either create the ``clusters`` file manually, or with a
``find`` or ``ls`` command in your source tree."


Using a Makefile
================

If you will repeatedly compute the dependencies for a codebase that
you maintain, you could write a simple script to do all the custom
things that you need to, for example::

  # Generate the raw dependencies.
  snakefood /myproject > /tmp/raw.deps

  # Filter and cluster.
  cd /myproject ; ls -1d * > /tmp/clusters
  cat /tmp/raw.deps | grep -v test_widget | snakefood-cluster -f /tmp/clusters > /tmp/filt.deps

  # Generate the graph.
  cat /tmp/filt.deps | snakefood-graph -p | dot -Tps | pstopdf -i -o /tmp/myproject.pdf

While this will work, a better way to write such a script is to use a
makefile.  

Here is an example for a simple self-contained ``Makefile`` that will
process the relevant dependencies as above::

  NAME = myproject
  ROOT = /path/to/myproject
  PDFS = $(NAME).pdf

  .SUFFIXES: .deps .dot .pdf .clusters

  all: $(PDFS)

  raw.deps: $(ROOT)
          snakefood -i $(ROOT) $(FOOD_FLAGS) > $@

  $(NAME).clusters: $(ROOT)
          cd $(ROOT) ; ls -1d * > $(shell pwd)/$@

  $(NAME).deps: $(NAME).clusters raw.deps
          cat raw.deps | snakefood-cluster -f $< > $@

  .deps.pdf:
          cat $< | snakefood-graph | dot -Tps | ps2pdf - $@

  clean:
          rm -f *.clusters *.dot *.pdf
          ls -1 *.deps | grep -v ^raw.deps | xargs rm -f

  realclean: clean
          rm -f raw.deps


For a set of more reusable make rules, take a look at
``snakefood/test/Makefile.rules`` and the Makefiles that we use to run
out tests on existing codebases.  You can probably leverage this for
your project (feel free to copy and modify it as needed).


Feedback and Comments
=====================

I wrote this script in may 2007.  I had previously tried to write a
reliable dependency grapher about 4 or 5 times, giving up each time on
the various intricacies of the Python import semantics.  I'm pretty
happy this time that I've found something reasonably reliable that
works everywhere.  Comments, feedback and donations are welcome.  I
hope you find this program useful.

